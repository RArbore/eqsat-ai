use core::str::FromStr;

use lalrpop_util::ParseError;

use crate::database::*;
use crate::frontend::*;
use crate::fixpoint::FunctionLibrary;

grammar<'a>(interner: &mut Interner, database: &mut Database<'a>, library: &FunctionLibrary);

pub Program: Vec<Rule> = {
    => Vec::new(),
    <mut p:Program> <x:Rule> ";" => {
        p.push(x);
        p
    },
    <p:Program> Declaration ";" => p,
}

Declaration: () = {
    "#" <s:Symbol> "(" <determinant:ColumnList> "->" <dependent:ColumnList> ")" => {
        database.register_table(s, Schema { determinant, dependent });
    },
}

ColumnList: Vec<SchemaColumn> = {
    => Vec::new(),
    <mut l:ColumnList> <x:Column> => {
        l.push(x);
        l
    },
}

Column: SchemaColumn = {
    "EClassId" => SchemaColumn::EClassId,
    "Int" => SchemaColumn::Int,
}

Rule: Rule = {
    <query:Query> "=>" <action:Action> => {
        Rule { query, action }
    }
}

Query: Query = {
    <atoms:AtomList> => {
        Query { atoms }
    }
}

Action: Action = {
    <atoms:AtomList> => {
        Action::InsertPattern{ atoms }
    },
    "'" <s:Symbol> "=>" <a:Action> =>? {
        let func = library.get(&s).ok_or(ParseError::User { error: "Unrecognized library function" })?.clone();
        Ok(Action::ComputeFunc { func, next: Box::new(a) })
    }
}

AtomList: Vec<Atom> = {
    => Vec::new(),
    <mut l:AtomList> <a:Atom> => {
        l.push(a);
        l
    }
}

Atom: Atom = {
    <s:Symbol> "(" <slots:SlotList> ")" => Atom { table: database.table_id(s), slots },
}

SlotList: Vec<Slot> = {
    => Vec::new(),
    <mut l:SlotList> <a:Slot> => {
        l.push(a);
        l
    }
}

Slot: Slot = {
    "_" => Slot::Wildcard,
    U32 => Slot::Concrete(<>),
    Symbol => Slot::Variable(<>),
}

Symbol: Symbol = {
    Iden => interner.get_or_intern(<>),
}

Usize: usize = r"-?[0-9]+" => usize::from_str(<>).unwrap();
U32: u32 = r"-?[0-9]+" => u32::from_str(<>).unwrap();
Iden: &'input str = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>;
